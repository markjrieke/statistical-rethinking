---
title: "Conditional Manatees"
output: 
  github_document:
    math_method: null
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  dpi = 500,
  fig.width = 9,
  fig.height = 6
)
```

* During WWII, Royal Air Force bombers were being shot down in droves --- those that weren't returned with bullet holes covering the wings, but no bullet holes on the engine/compartment.
* The air force needed to protect the bombers as efficiently as possible --- but putting more armor on the areas that had the most bullet holes wouldn't work!
* This is because wings can withstand bullet damage, but the engine can't!
* In this way, data (like the bomber damage), is *conditional* on how they get into the sample.
* Sometimes, the importance of one predictor depends on another predictor --- this is known as an *interaction*. 

## 8.1 Building an interaction

* In countries outside Africa, GDP (or rather, log(GDP)) is negatively associated with terrain ruggedness. For countries within Africa, however, there's a positive relationship! This is a clear indication of an interaction. 
* If *R* is terrain ruggedness, *G* is GDP, *C* is continent, and *U* is some set of unobserved confounders, a potential DAG may look like:

```{r}
library(rethinking)
library(dagitty)

africa_dag <-
  dagitty(
    "dag{
      U [unobserved]
      U -> R
      U -> G
      R -> G
      C -> G
    }"
  )

coordinates(africa_dag) <-
  list(x = c(R = 0, G = 1, C = 2, U = 1),
       y = c(R = 0, G = 0, C = 0, U = 1))

drawdag(africa_dag)
```

* Here, both *R* and *C* influence *G*. This could be independent, or through an interaction (DAGs don't describe whethere there is an action, just says that *G* is *some function* of *R* and *G*). 
* Splitting the data into separate models for different continents isn't a great idea, for a few reasons:
  1. Some variables (like $\sigma$) may not depend on the continent at all
  2. In order to learn something about the continent variable itself, we need to include it directly in the model!
  3. We may want to compare models based on an information criteria, & it's only useful to do so with models that use the same data
  4. Once we get into multilevel models, we'll see that there's a lot of benefit to "borrowing" information across categories. 

### 8.1.1 Making a rugged model

* Let's first fit a model that *doesn't* use an interaction between continent & ruggedness.

```{r}
data(rugged)
d <- rugged

# make log version of outcome
d$log_gdp <- log(d$rgdppc_2000)

# extract countries with GDP data
dd <- d[complete.cases(d$rgdppc_2000), ]

# rescale variables
dd$log_gdp_std <- dd$log_gdp / mean(dd$log_gdp)
dd$rugged_std <- dd$rugged / max(dd$rugged)
```

* Scaling makes setting the priors a bit easier to work with --- a $\mu$ value of 1 corresponds to the average log(GDP), so a $Normal(1,1)$ prior makes sense. 
* $\beta$ has no bias towards positive or negative, so a $Normal(0,1)$ prior is reasonable. 
* Finally, if we assume we have no knowledge about standard deviation, we can use an $Exponential(1)$ prior for $\sigma$. 

$$
\begin{gather}
log(y_i) \sim Normal(\mu_i, \sigma) \\
\mu_i = \alpha + \beta(r_i - \overline{r}) \\
\alpha \sim Normal(1, 1) \\
\beta \sim Normal(0, 1) \\
\sigma \sim Exponential(1) 
\end{gather}
$$

```{r}
# build a model
m8.1 <-
  quap(
    alist(log_gdp_std ~ dnorm(mu, sigma),
          mu <- a + b*(rugged_std - 0.215), # 0.215 is the average ruggedness, courtesy of Dr. McElreath
          a ~ dnorm(1, 1),
          b ~ dnorm(0, 1),
          sigma ~ dexp(1)),
    data = dd
  )

# put together prior predictions
set.seed(7)
prior <- extract.prior(m8.1)

# plot!
plot(NULL,
     xlim = c(0,1),
     ylim = c(0.5, 1.5),
     xlab = "ruggedness",
     ylab = "log GDP")

abline(h = min(dd$log_gdp_std), lty = 2)
abline(h = max(dd$log_gdp_std), lty = 2)

# draw 50 lines from the prior
rugged_seq <- seq(rom = 0.1, to = 1.1, length.out = 30)
mu <- link(m8.1, post = prior, data = data.frame(rugged_std = rugged_seq))
for (i in 1:50) lines(rugged_seq, mu[i,], col = col.alpha("black", 0.3))
```

* Oh no! many of these regression lines end up in impossible territory!
* Let's update our priors to be more reasonable, given what we know about what ought to be reasonable:

```{r}
m8.1 <-
  quap(
    alist(log_gdp_std ~ dnorm(mu, sigma),
          mu <- a + b*(rugged_std - 0.215),
          a ~ dnorm(1, 0.1),
          b ~ dnorm(0, 0.3),
          sigma ~ dexp(1)),
    data = dd
  )

# replot priors
set.seed(7)
prior <- extract.prior(m8.1)

# plot!
plot(NULL,
     xlim = c(0,1),
     ylim = c(0.5, 1.5),
     xlab = "ruggedness",
     ylab = "log GDP")

abline(h = min(dd$log_gdp_std), lty = 2)
abline(h = max(dd$log_gdp_std), lty = 2)

# draw 50 lines from the prior
rugged_seq <- seq(rom = 0.1, to = 1.1, length.out = 30)
mu <- link(m8.1, post = prior, data = data.frame(rugged_std = rugged_seq))
for (i in 1:50) lines(rugged_seq, mu[i,], col = col.alpha("black", 0.3))
```

* Much more reasonable! 
* Now what is the posterior relationship between ruggedness & log(GDP)?

```{r}
precis(m8.1)
```

* Basically nothing!





